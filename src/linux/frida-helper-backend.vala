namespace Frida {
	public class LinuxHelperBackend : Object, LinuxHelper {
		public signal void idle ();

		public bool is_idle {
			get {
				return inject_instances.is_empty;
			}
		}

		public Gee.HashMap<uint, void *> spawn_instances = new Gee.HashMap<uint, void *> ();
		private Gee.HashMap<uint, uint> watch_sources = new Gee.HashMap<uint, uint> ();
		private Gee.HashMap<uint, OutputStream> stdin_streams = new Gee.HashMap<uint, OutputStream> ();

		public Gee.HashMap<uint, void *> exec_instances = new Gee.HashMap<uint, void *> ();
		private Gee.HashMap<uint, uint> exec_waiters = new Gee.HashMap<uint, uint> ();
		private uint next_waiter_id = 1;

		public Gee.HashMap<uint, void *> syscall_instances = new Gee.HashMap<uint, void *> ();

		private Gee.HashMap<uint, RemoteAgent> remote_agents = new Gee.HashMap<uint, RemoteAgent> ();
		public Gee.HashMap<uint, void *> inject_instances = new Gee.HashMap<uint, void *> ();
		private Gee.HashMap<uint, RemoteThreadSession> inject_sessions = new Gee.HashMap<uint, RemoteThreadSession> ();
		private Gee.HashMap<uint, uint> inject_expiry_by_id = new Gee.HashMap<uint, uint> ();

		private Gee.Map<uint, Gee.Queue<TaskEntry>> task_queues = new Gee.HashMap<uint, Gee.Queue<TaskEntry>> ();

		public uint next_id = 0;

		private Cancellable io_cancellable = new Cancellable ();

		~LinuxHelperBackend () {
			foreach (var instance in spawn_instances.values)
				_free_spawn_instance (instance);
			foreach (var instance in exec_instances.values)
				_free_exec_instance (instance);
			foreach (var instance in syscall_instances.values)
				_free_syscall_instance (instance);
			foreach (var instance in inject_instances.values)
				_free_inject_instance (instance, RESIDENT);
		}

		public async void close (Cancellable? cancellable) throws IOError {
			io_cancellable.cancel ();
		}

		public async uint spawn (string path, HostSpawnOptions options, Cancellable? cancellable) throws Error, IOError {
			if (!FileUtils.test (path, EXISTS))
				throw new Error.EXECUTABLE_NOT_FOUND ("Unable to find executable at '%s'", path);

			StdioPipes? pipes;
			var child_pid = _do_spawn (path, options, out pipes);

			monitor_child (child_pid);

			if (pipes != null) {
				stdin_streams[child_pid] = new UnixOutputStream (pipes.input, false);
				process_next_output_from.begin (new UnixInputStream (pipes.output, false), child_pid, 1, pipes);
				process_next_output_from.begin (new UnixInputStream (pipes.error, false), child_pid, 2, pipes);
			}

			return child_pid;
		}

		private void monitor_child (uint pid) {
			watch_sources[pid] = ChildWatch.add ((Pid) pid, on_child_dead);
		}

		private void demonitor_child (uint pid) {
			uint watch_id;
			if (watch_sources.unset (pid, out watch_id))
				Source.remove (watch_id);
		}

		private void on_child_dead (Pid pid, int status) {
			watch_sources.unset (pid);

			stdin_streams.unset (pid);

			void * instance;
			if (spawn_instances.unset (pid, out instance))
				_free_spawn_instance (instance);
		}

		private async void process_next_output_from (InputStream stream, uint pid, int fd, Object resource) {
			try {
				var buf = new uint8[4096];
				var n = yield stream.read_async (buf, Priority.DEFAULT, io_cancellable);

				var data = buf[0:n];
				output (pid, fd, data);

				if (n > 0)
					process_next_output_from.begin (stream, pid, fd, resource);
			} catch (GLib.Error e) {
				if (!(e is IOError.CANCELLED))
					output (pid, fd, new uint8[0]);
			}
		}

		public async void prepare_exec_transition (uint pid, Cancellable? cancellable) throws Error, IOError {
			bool is_child = spawn_instances.has_key (pid);
			if (is_child)
				demonitor_child (pid);

			try {
				_do_prepare_exec_transition (pid);
			} catch (Error e) {
				if (is_child)
					monitor_child (pid);
				throw e;
			}

			_notify_exec_pending (pid, true);
		}

		public async void await_exec_transition (uint pid, Cancellable? cancellable) throws Error, IOError {
			var instance = exec_instances[pid];
			if (instance == null)
				throw new Error.INVALID_ARGUMENT ("Invalid PID");

			if (!_try_transition_exec_instance (instance)) {
				uint id = next_waiter_id++;
				Error? pending_error = null;

				exec_waiters[pid] = id;

				Timeout.add (50, () => {
					var cancelled = !exec_waiters.has (pid, id);
					if (cancelled) {
						await_exec_transition.callback ();
						return false;
					}

					try {
						if (_try_transition_exec_instance (instance)) {
							await_exec_transition.callback ();
							return false;
						}
					} catch (Error e) {
						pending_error = e;
						await_exec_transition.callback ();
						return false;
					}

					return true;
				});

				yield;

				var cancelled = !exec_waiters.has (pid, id);
				if (cancelled)
					throw new Error.INVALID_OPERATION ("Cancelled");
				exec_waiters.unset (pid);

				if (pending_error != null) {
					exec_instances.unset (pid);

					_resume_exec_instance (instance);
					_free_exec_instance (instance);

					_notify_exec_pending (pid, false);

					throw pending_error;
				}
			}

			if (spawn_instances.has_key (pid))
				monitor_child (pid);
		}

		public async void cancel_exec_transition (uint pid, Cancellable? cancellable) throws Error, IOError {
			void * instance;
			if (!exec_instances.unset (pid, out instance))
				throw new Error.INVALID_ARGUMENT ("Invalid PID");

			exec_waiters.unset (pid);

			_suspend_exec_instance (instance);
			_resume_exec_instance (instance);
			_free_exec_instance (instance);

			if (spawn_instances.has_key (pid))
				monitor_child (pid);
			_notify_exec_pending (pid, false);
		}

		public async void await_syscall (uint pid, LinuxSyscall mask, Cancellable? cancellable) throws Error, IOError {
			if (syscall_instances.has_key (pid))
				throw new Error.INVALID_OPERATION ("Invalid operation");

			_do_await_syscall (pid, mask);
		}

		public async void resume_syscall (uint pid, Cancellable? cancellable) throws Error, IOError {
			void * instance;
			if (!syscall_instances.unset (pid, out instance))
				throw new Error.INVALID_ARGUMENT ("Invalid PID");

			_free_syscall_instance (instance);
		}

		public async void input (uint pid, uint8[] data, Cancellable? cancellable) throws Error, IOError {
			var stream = stdin_streams[pid];
			if (stream == null)
				throw new Error.INVALID_ARGUMENT ("Invalid PID");
			try {
				yield stream.write_all_async (data, Priority.DEFAULT, null, null);
			} catch (GLib.Error e) {
				throw new Error.TRANSPORT ("%s", e.message);
			}
		}

		public async void resume (uint pid, Cancellable? cancellable) throws Error, IOError {
			void * instance;
			bool instance_found;

			instance_found = spawn_instances.unset (pid, out instance);
			if (instance_found) {
				_resume_spawn_instance (instance);
				_free_spawn_instance (instance);
				return;
			}

			if (exec_waiters.has_key (pid))
				throw new Error.INVALID_OPERATION ("Invalid operation");

			instance_found = exec_instances.unset (pid, out instance);
			if (instance_found) {
				_resume_exec_instance (instance);
				_free_exec_instance (instance);
				return;
			}

			throw new Error.INVALID_ARGUMENT ("Invalid PID");
		}

		public async void kill (uint pid, Cancellable? cancellable) throws Error, IOError {
			Posix.kill ((Posix.pid_t) pid, Posix.Signal.KILL);
		}

		public async void inject_library_file (uint pid, PathTemplate path_template, string entrypoint, string data,
				string temp_path, uint id, Cancellable? cancellable) throws Error, IOError {
			string path = path_template.expand (arch_name_from_pid (pid));

			var task = new InjectTask (pid, path, entrypoint, data, id);
			RemoteAgent agent = yield perform (task, pid, cancellable);
			if (agent.state == STOPPED) {
				var source = new IdleSource ();
				source.set_callback (() => {
					on_agent_stopped (agent);
					return false;
				});
				source.attach (MainContext.get_thread_default ());
				return;
			}
			remote_agents[id] = agent;
			agent.notify["state"].connect (on_agent_state_changed);

			/*
			_do_inject (pid, path, entrypoint, data, temp_path, id);

			yield establish_session (id, pid);
			*/
		}

		public async IOStream request_control_channel (uint id, Cancellable? cancellable) throws Error, IOError {
			if (inject_instances.has_key (id))
				throw new Error.NOT_SUPPORTED ("Control channel not supported by legacy injector internals");

			RemoteAgent agent = remote_agents[id];
			if (agent == null)
				throw new Error.INVALID_ARGUMENT ("Invalid ID");

			return agent.agent_ctrl;
		}

		private class InjectTask : Object, Task<RemoteAgent> {
			private uint pid;
			private string path;
			private string entrypoint;
			private string data;
			private uint id;

			public InjectTask (uint pid, string path, string entrypoint, string data, uint id) {
				this.pid = pid;
				this.path = path;
				this.entrypoint = entrypoint;
				this.data = data;
				this.id = id;
			}

			public async RemoteAgent run (Cancellable? cancellable) throws Error, IOError {
				var session = yield InjectSession.open (pid, cancellable);
				return yield session.inject (path, entrypoint, data, id, cancellable);
			}
		}

		private void on_agent_state_changed (Object object, ParamSpec pspec) {
			var agent = (RemoteAgent) object;
			if (agent.state == STOPPED)
				on_agent_stopped (agent);
		}

		private void on_agent_stopped (RemoteAgent agent) {
			uint id = agent.id;

			uninjected (id);

			if (agent.unload_policy == IMMEDIATE) {
				deallocate_agent.begin (agent);
			} else {
				remote_agents.unset (id);
				maybe_emit_idle ();
			}
		}

		private async void deallocate_agent (RemoteAgent agent) {
			uint pid = agent.pid;
			var task = new DeallocateTask (pid, agent);
			try {
				yield perform<RemoteAgent> (task, pid, null);
			} catch (GLib.Error e) {
			}

			remote_agents.unset (agent.id);
			maybe_emit_idle ();
		}

		private class DeallocateTask : Object, Task<RemoteAgent> {
			private uint pid;
			private RemoteAgent agent;

			public DeallocateTask (uint pid, RemoteAgent agent) {
				this.pid = pid;
				this.agent = agent;
			}

			public async RemoteAgent run (Cancellable? cancellable) throws Error, IOError {
				var session = yield CleanupSession.open (pid, cancellable);
				yield session.deallocate (agent.layout, cancellable);
				return agent;
			}
		}

		public async void demonitor (uint id, Cancellable? cancellable) throws Error, IOError {
			RemoteAgent agent;
			if (remote_agents.unset (id, out agent)) {
				yield agent.demonitor ();
				schedule_inject_expiry_for_id (id);
				return;
			}

			var instance = inject_instances[id];
			if (instance == null)
				throw new Error.INVALID_ARGUMENT ("Invalid ID");

			RemoteThreadSession session;
			if (inject_sessions.unset (id, out session)) {
				session.ended.disconnect (on_remote_thread_session_ended);
				yield session.cancel ();
			}

			_demonitor (instance);

			schedule_inject_expiry_for_id (id);
		}

		public async void demonitor_and_clone_injectee_state (uint id, uint clone_id, Cancellable? cancellable) throws Error, IOError {
			// TODO: Wire up for remote agents.

			var instance = inject_instances[id];
			if (instance == null)
				throw new Error.INVALID_ARGUMENT ("Invalid ID");

			RemoteThreadSession session;
			if (inject_sessions.unset (id, out session)) {
				session.ended.disconnect (on_remote_thread_session_ended);
				yield session.cancel ();
			}

			_demonitor_and_clone_injectee_state (instance, clone_id);

			schedule_inject_expiry_for_id (id);
			schedule_inject_expiry_for_id (clone_id);
		}

		public async void recreate_injectee_thread (uint pid, uint id, Cancellable? cancellable) throws Error, IOError {
			// TODO: Wire up for remote agents.

			var instance = inject_instances[id];
			if (instance == null)
				throw new Error.INVALID_ARGUMENT ("Invalid ID");

			cancel_inject_expiry_for_id (id);

			_recreate_injectee_thread (instance, pid);

			yield establish_session (id, pid);
		}

		private async void establish_session (uint id, uint pid) throws Error {
			var fifo = _get_fifo_for_inject_instance (inject_instances[id]);

			var session = new RemoteThreadSession (id, pid, fifo);
			try {
				yield session.establish ();
			} catch (Error e) {
				_destroy_inject_instance (id, IMMEDIATE);
				throw e;
			}

			inject_sessions[id] = session;
			session.ended.connect (on_remote_thread_session_ended);
		}

		private void on_remote_thread_session_ended (RemoteThreadSession session, UnloadPolicy unload_policy) {
			var id = session.id;

			session.ended.disconnect (on_remote_thread_session_ended);
			inject_sessions.unset (id);

			_destroy_inject_instance (id, unload_policy);
		}

		protected void _destroy_inject_instance (uint id, UnloadPolicy unload_policy) {
			void * instance;
			bool found = inject_instances.unset (id, out instance);
			assert (found);

			_free_inject_instance (instance, unload_policy);

			uninjected (id);

			maybe_emit_idle ();
		}

		private void schedule_inject_expiry_for_id (uint id) {
			uint previous_timer;
			if (inject_expiry_by_id.unset (id, out previous_timer))
				Source.remove (previous_timer);

			inject_expiry_by_id[id] = Timeout.add_seconds (20, () => {
				var removed = inject_expiry_by_id.unset (id);
				assert (removed);

				if (remote_agents.has_key (id))
					on_agent_stopped (remote_agents[id]);
				else
					_destroy_inject_instance (id, IMMEDIATE);

				return false;
			});
		}

		private void cancel_inject_expiry_for_id (uint id) {
			uint timer;
			var found = inject_expiry_by_id.unset (id, out timer);
			assert (found);

			Source.remove (timer);
		}

		private static unowned string arch_name_from_pid (uint pid) throws Error {
			Gum.CpuType cpu_type;
			try {
				cpu_type = Gum.Linux.cpu_type_from_pid ((Posix.pid_t) pid);
			} catch (GLib.Error e) {
				if (e is FileError.NOENT)
					throw new Error.PROCESS_NOT_FOUND ("Unable to find process with pid %u".printf (pid));
				else if (e is FileError.ACCES)
					throw new Error.PERMISSION_DENIED ("Unable to access process with pid %u from the current user account".printf (pid));
				else
					throw new Error.NOT_SUPPORTED ("%s", e.message);
			}

			switch (cpu_type) {
				case Gum.CpuType.IA32:
				case Gum.CpuType.ARM:
				case Gum.CpuType.MIPS:
					return "32";

				case Gum.CpuType.AMD64:
				case Gum.CpuType.ARM64:
					return "64";

				default:
					assert_not_reached ();
			}
		}

		private void maybe_emit_idle () {
			if (remote_agents.is_empty && inject_instances.is_empty)
				idle ();
		}

		private async T perform<T> (Task<T> task, uint pid, Cancellable? cancellable) throws Error, IOError {
			Gee.Queue<TaskEntry> queue = task_queues[pid];
			if (queue == null) {
				queue = new Gee.ArrayQueue<TaskEntry> ();
				task_queues[pid] = queue;

				var source = new IdleSource ();
				source.set_callback (() => {
					process_tasks.begin (queue, pid);
					return false;
				});
				source.attach (MainContext.get_thread_default ());
			}

			var entry = new TaskEntry ((Task<Object>) task, cancellable);
			queue.offer (entry);

			return yield entry.promise.future.wait_async (cancellable);
		}

		private async void process_tasks (Gee.Queue<TaskEntry> queue, uint pid) {
			TaskEntry entry;
			while ((entry = queue.poll ()) != null) {
				try {
					entry.cancellable.set_error_if_cancelled ();
					var result = yield entry.task.run (entry.cancellable);
					entry.promise.resolve (result);
				} catch (GLib.Error e) {
					entry.promise.reject (e);
				}
			}

			task_queues.unset (pid);
		}

		private class TaskEntry {
			public Task<Object> task;
			public Cancellable? cancellable;
			public Promise<Object> promise = new Promise<Object> ();

			public TaskEntry (Task<Object> task, Cancellable? cancellable) {
				this.task = task;
				this.cancellable = cancellable;
			}
		}

		private interface Task<T> : Object {
			public abstract async T run (Cancellable? cancellable) throws Error, IOError;
		}

		protected extern uint _do_spawn (string path, HostSpawnOptions options, out StdioPipes? pipes) throws Error;
		protected extern void _resume_spawn_instance (void * instance);
		protected extern void _free_spawn_instance (void * instance);

		protected extern void _do_prepare_exec_transition (uint pid) throws Error;
		protected extern void _notify_exec_pending (uint pid, bool pending);
		protected extern bool _try_transition_exec_instance (void * instance) throws Error;
		protected extern void _suspend_exec_instance (void * instance);
		protected extern void _resume_exec_instance (void * instance);
		protected extern void _free_exec_instance (void * instance);

		protected extern void _do_await_syscall (uint pid, LinuxSyscall mask) throws Error;
		protected extern void _free_syscall_instance (void * instance);

		protected extern void _do_inject (uint pid, string path, string entrypoint, string data, string temp_path, uint id) throws Error;
		protected extern void _demonitor (void * instance);
		protected extern uint _demonitor_and_clone_injectee_state (void * instance, uint clone_id);
		protected extern void _recreate_injectee_thread (void * instance, uint pid) throws Error;
		protected extern InputStream _get_fifo_for_inject_instance (void * instance);
		protected extern void _free_inject_instance (void * instance, UnloadPolicy unload_policy);
	}

	private class InjectSession : SeizeSession {
		private InjectSession (uint pid) {
			Object (pid: pid);
		}

		public static async InjectSession open (uint pid, Cancellable? cancellable) throws Error, IOError {
			var session = new InjectSession (pid);

			try {
				yield session.init_async (Priority.DEFAULT, cancellable);
			} catch (GLib.Error e) {
				if (e is Error)
					throw (Error) e;
				assert (e is IOError);
				throw (IOError) e;
			}

			return session;
		}

		public async RemoteAgent inject (string path, string entrypoint, string data, uint id, Cancellable? cancellable)
				throws Error, IOError {
			// TODO: Suspend other threads.
			RemoteAgent agent;

			var pc = saved_regs.program_counter;
			uint64 hijacked_code_start = pc & ~(4096 - 1);

			GPRegs regs = saved_regs;
			regs.orig_rax = -1;
			regs.program_counter = hijacked_code_start + BOOTSTRAPPER_ENTRYPOINT_OFFSET;

			var original_code = read_memory (hijacked_code_start, BOOTSTRAPPER_CODE.length);
			write_memory (hijacked_code_start, BOOTSTRAPPER_CODE);

			regs.reserve_stack_space (RED_ZONE_SIZE);
			regs.reserve_stack_space ((size_t) (regs.stack_pointer % STACK_ALIGNMENT));

			uint64 libc_api_location = regs.reserve_stack_space (sizeof (HelperLibcApi));
			uint64 bootstrap_ctx_location = regs.reserve_stack_space (sizeof (HelperBootstrapContext));

			size_t loader_code_size = LOADER_CODE.length;
			loader_code_size = round_size_to_page_size (loader_code_size);

			size_t path_cstring_size = path.length + 1;
			size_t entrypoint_cstring_size = entrypoint.length + 1;
			size_t data_cstring_size = data.length + 1;

			size_t loader_data_size = 0;
			loader_data_size += sizeof (HelperLoaderContext);
			loader_data_size += sizeof (HelperLibcApi);
			loader_data_size += path_cstring_size;
			loader_data_size += entrypoint_cstring_size;
			loader_data_size += data_cstring_size;
			loader_data_size = round_size_to_page_size (loader_data_size);

			size_t loader_ctx_offset = loader_code_size;
			size_t loader_libc_api_offset = loader_ctx_offset + sizeof (HelperLoaderContext);
			size_t agent_path_offset = loader_libc_api_offset + sizeof (HelperLibcApi);
			size_t agent_entrypoint_offset = agent_path_offset + path_cstring_size;
			size_t agent_parameters_offset = agent_entrypoint_offset + entrypoint_cstring_size;

			var bootstrap_ctx = HelperBootstrapContext ();
			bootstrap_ctx.loader_size = loader_code_size + loader_data_size;
			bootstrap_ctx.enable_ctrlfds = pidfd_getfd != null;
			bootstrap_ctx.libc_api = (HelperLibcApi *) libc_api_location;
			write_memory (bootstrap_ctx_location, (uint8[]) &bootstrap_ctx);
			regs.rdi = bootstrap_ctx_location;

			regs.reserve_stack_space ((size_t) (regs.stack_pointer % STACK_ALIGNMENT));

			regs.rsp -= 8;
			ptrace (POKEDATA, pid, (void *) regs.rsp, (void *) DUMMY_RETURN_ADDRESS);

			set_regs (&regs);

			ptrace (CONT, pid);
			Posix.Signal next_signal = yield wait_for_next_signal (cancellable);
			get_regs (&regs);
			if (regs.program_counter != DUMMY_RETURN_ADDRESS || regs.return_value != 0) {
				set_regs (&saved_regs);
				write_memory (hijacked_code_start, original_code);
				// TODO: Resume other threads.
				throw new Error.NOT_SUPPORTED ("Bootstrapper failed (code %" + uint64.FORMAT_MODIFIER + "u); " +
					"please file a bug",
					regs.return_value);
			}

			write_memory (hijacked_code_start, original_code);
			// TODO: Resume other threads.

			uint8[] bootstrap_result = read_memory (bootstrap_ctx_location, sizeof (HelperBootstrapContext));
			Memory.copy (&bootstrap_ctx, bootstrap_result, sizeof (HelperBootstrapContext));

			uint8[] libc_result = read_memory (libc_api_location, sizeof (HelperLibcApi));
			var libc = HelperLibcApi ();
			Memory.copy (&libc, libc_result, sizeof (HelperLibcApi));

			var loader_base = (uint64) bootstrap_ctx.loader_base;

			if (pidfd_getfd != null && bootstrap_ctx.ctrlfds[0] != -1) {
				var sockfd = pidfd_getfd (pidfd, bootstrap_ctx.ctrlfds[0], 0);
				Socket socket;
				try {
					socket = new Socket.from_fd (sockfd);
				} catch (GLib.Error e) {
					assert_not_reached ();
				}
				var stream = SocketConnection.factory_create_connection (socket);
				var layout = new RemoteAgent.MemoryLayout (loader_base, bootstrap_ctx.loader_size, (uint64) libc.munmap);
				agent = RemoteAgent.start (id, pid, layout, (UnixConnection) stream, path, cancellable);
			} else {
				throw new Error.NOT_SUPPORTED ("Out-of-band agent establishment not yet implemented");
			}

			write_memory (loader_base, LOADER_CODE);
			var loader_ctx = HelperLoaderContext ();
			loader_ctx.agent_path = (char *) (loader_base + agent_path_offset);
			loader_ctx.agent_entrypoint = (char *) (loader_base + agent_entrypoint_offset);
			loader_ctx.agent_parameters = (char *) (loader_base + agent_parameters_offset);
			loader_ctx.ctrlfds = bootstrap_ctx.ctrlfds;
			loader_ctx.libc_api = (HelperLibcApi *) (loader_base + loader_libc_api_offset);
			write_memory (loader_base + loader_ctx_offset, (uint8[]) &loader_ctx);
			write_memory (loader_base + loader_libc_api_offset, libc_result);
			write_memory (loader_base + agent_path_offset, path.data);
			write_memory (loader_base + agent_entrypoint_offset, entrypoint.data);
			write_memory (loader_base + agent_parameters_offset, data.data);

			regs = saved_regs;
			regs.orig_rax = -1;

			regs.program_counter = loader_base + LOADER_ENTRYPOINT_OFFSET;

			regs.rdi = loader_base + loader_ctx_offset;

			regs.reserve_stack_space (RED_ZONE_SIZE);
			regs.reserve_stack_space ((size_t) (regs.stack_pointer % STACK_ALIGNMENT));

			regs.rsp -= 8;
			ptrace (POKEDATA, pid, (void *) regs.rsp, (void *) DUMMY_RETURN_ADDRESS);

			set_regs (&regs);

			ptrace (CONT, pid);
			next_signal = yield wait_for_next_signal (cancellable);
			get_regs (&regs);
			if (regs.program_counter != DUMMY_RETURN_ADDRESS || regs.return_value == 0) {
				set_regs (&saved_regs);
				throw new Error.NOT_SUPPORTED ("Loader failed; please file a bug");
			}

			// TODO

			set_regs (&saved_regs);

			return agent;
		}

		private static size_t round_size_to_page_size (size_t size) {
			size_t page_size = Gum.query_page_size ();
			return (size + page_size - 1) & ~(page_size - 1);
		}

		private const uint8[] BOOTSTRAPPER_CODE = {
			0xb8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xb6, 0x14, 0x07, 0x3a, 0x14, 0x06, 0x75, 0x0e, 0x48, 0x83, 0xc0, 0x01, 0x84,
			0xd2, 0x75, 0xef, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xc3, 0xb8, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xb8, 0x01, 0x00, 0x00,
			0x00, 0x80, 0x7f, 0x10, 0x02, 0x0f, 0x85, 0xc0, 0x02, 0x00, 0x00, 0x41, 0x54, 0x55, 0x53, 0x48, 0x89, 0xfd, 0x49,
			0x89, 0xf4, 0x48, 0x8b, 0x5e, 0x08, 0x48, 0x83, 0x3b, 0x00, 0x0f, 0x84, 0x91, 0x00, 0x00, 0x00, 0x48, 0x83, 0x7b,
			0x08, 0x00, 0x0f, 0x84, 0xab, 0x00, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x10, 0x00, 0x0f, 0x84, 0xc7, 0x00, 0x00, 0x00,
			0x48, 0x83, 0x7b, 0x18, 0x00, 0x0f, 0x84, 0xe3, 0x00, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x20, 0x00, 0x0f, 0x84, 0x02,
			0x01, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x28, 0x00, 0x0f, 0x84, 0x21, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x30, 0x00,
			0x0f, 0x84, 0x40, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x38, 0x00, 0x0f, 0x84, 0x5f, 0x01, 0x00, 0x00, 0x48, 0x83,
			0x7b, 0x40, 0x00, 0x0f, 0x84, 0x7e, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x48, 0x00, 0x0f, 0x84, 0x9d, 0x01, 0x00,
			0x00, 0x48, 0x83, 0x7b, 0x50, 0x00, 0x0f, 0x84, 0xbc, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x58, 0x00, 0x0f, 0x84,
			0xdb, 0x01, 0x00, 0x00, 0x48, 0x83, 0x7b, 0x60, 0x00, 0x0f, 0x84, 0xfa, 0x01, 0x00, 0x00, 0x41, 0x83, 0x3c, 0x24,
			0x00, 0x0f, 0x9f, 0xc0, 0x5b, 0x5d, 0x41, 0x5c, 0xc3, 0x48, 0x8b, 0x3f, 0x48, 0x8d, 0x35, 0x1d, 0x0f, 0x00, 0x00,
			0xe8, 0x17, 0xff, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x58, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89,
			0x03, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xeb, 0xce, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0xf6, 0x0e, 0x00, 0x00,
			0xe8, 0xf1, 0xfe, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x3d, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89,
			0x43, 0x08, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xeb, 0xa7, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0xd7, 0x0e, 0x00,
			0x00, 0xe8, 0xca, 0xfe, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x21, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48,
			0x89, 0x43, 0x10, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xeb, 0x80, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0xb5, 0x0e,
			0x00, 0x00, 0xe8, 0xa3, 0xfe, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x05, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08,
			0x48, 0x89, 0x43, 0x18, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0x56, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00, 0x48,
			0x8d, 0x35, 0x92, 0x0e, 0x00, 0x00, 0xe8, 0x79, 0xfe, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0xe6, 0xfe, 0xff, 0xff,
			0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43, 0x20, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0x2c, 0xff, 0xff, 0xff, 0x48,
			0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0x73, 0x0e, 0x00, 0x00, 0xe8, 0x4f, 0xfe, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84,
			0xc7, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43, 0x28, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0x02,
			0xff, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0x51, 0x0e, 0x00, 0x00, 0xe8, 0x25, 0xfe, 0xff, 0xff,
			0x84, 0xc0, 0x0f, 0x84, 0xa8, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43, 0x30, 0x41, 0x83, 0x2c,
			0x24, 0x01, 0xe9, 0xd8, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0x53, 0x0e, 0x00, 0x00, 0xe8,
			0xfb, 0xfd, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x89, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43,
			0x38, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0xae, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0x02,
			0x0e, 0x00, 0x00, 0xe8, 0xd1, 0xfd, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x6a, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45,
			0x08, 0x48, 0x89, 0x43, 0x40, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0x84, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00,
			0x48, 0x8d, 0x35, 0xe7, 0x0d, 0x00, 0x00, 0xe8, 0xa7, 0xfd, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x4b, 0xfe, 0xff,
			0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43, 0x48, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0x5a, 0xfe, 0xff, 0xff,
			0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0xcc, 0x0d, 0x00, 0x00, 0xe8, 0x7d, 0xfd, 0xff, 0xff, 0x84, 0xc0, 0x0f,
			0x84, 0x2c, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43, 0x50, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9,
			0x30, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0xa9, 0x0d, 0x00, 0x00, 0xe8, 0x53, 0xfd, 0xff,
			0xff, 0x84, 0xc0, 0x0f, 0x84, 0x0d, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89, 0x43, 0x58, 0x41, 0x83,
			0x2c, 0x24, 0x01, 0xe9, 0x06, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x7d, 0x00, 0x48, 0x8d, 0x35, 0x87, 0x0d, 0x00, 0x00,
			0xe8, 0x29, 0xfd, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0xee, 0xfd, 0xff, 0xff, 0x48, 0x8b, 0x45, 0x08, 0x48, 0x89,
			0x43, 0x60, 0x41, 0x83, 0x2c, 0x24, 0x01, 0xe9, 0xdc, 0xfd, 0xff, 0xff, 0xc3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55,
			0x41, 0x54, 0x55, 0x53, 0x48, 0x81, 0xec, 0x48, 0x08, 0x00, 0x00, 0x48, 0x89, 0xfd, 0x48, 0xb8, 0x2f, 0x70, 0x72,
			0x6f, 0x63, 0x2f, 0x73, 0x65, 0x48, 0xba, 0x6c, 0x66, 0x2f, 0x6d, 0x61, 0x70, 0x73, 0x00, 0x48, 0x89, 0x44, 0x24,
			0x10, 0x48, 0x89, 0x54, 0x24, 0x18, 0x48, 0x8d, 0x7c, 0x24, 0x10, 0xbe, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xba, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xba, 0x01, 0x00, 0x00,
			0x00, 0x83, 0xf8, 0xff, 0x0f, 0x84, 0x76, 0x04, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0xbb, 0xff, 0x07,
			0x00, 0x00, 0x4c, 0x8d, 0x4c, 0x24, 0x40, 0x48, 0x63, 0xf8, 0xe9, 0xe0, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc9, 0x0f,
			0x84, 0xc8, 0x00, 0x00, 0x00, 0xc6, 0x01, 0x00, 0x0f, 0xb6, 0x10, 0x84, 0xd2, 0x75, 0x6a, 0xe9, 0x97, 0x00, 0x00,
			0x00, 0x49, 0x29, 0xd0, 0x49, 0x8d, 0x50, 0x01, 0x49, 0x39, 0xc1, 0x73, 0x27, 0x48, 0x85, 0xd2, 0x0f, 0x84, 0xee,
			0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xb6, 0x0c, 0x10, 0x42, 0x88, 0x0c, 0x0a, 0x48, 0x89, 0xd1,
			0x48, 0x83, 0xc2, 0x01, 0x4c, 0x39, 0xc1, 0x75, 0xec, 0xe9, 0x95, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x4c, 0x24, 0x40,
			0x48, 0x39, 0xc8, 0x0f, 0x83, 0x87, 0x00, 0x00, 0x00, 0x48, 0x85, 0xd2, 0x0f, 0x84, 0xc2, 0x00, 0x00, 0x00, 0x48,
			0x83, 0xea, 0x01, 0x0f, 0xb6, 0x0c, 0x10, 0x42, 0x88, 0x0c, 0x0a, 0x75, 0xf2, 0xeb, 0x6e, 0x48, 0x83, 0xc0, 0x01,
			0x0f, 0xb6, 0x10, 0x84, 0xd2, 0x74, 0x32, 0x80, 0xfa, 0x6c, 0x75, 0xf0, 0x48, 0x89, 0xc2, 0x48, 0x8d, 0x35, 0x6d,
			0x0c, 0x00, 0x00, 0x48, 0x83, 0xc6, 0x01, 0x44, 0x0f, 0xb6, 0x56, 0xff, 0x45, 0x84, 0xd2, 0x74, 0x0c, 0x48, 0x83,
			0xc2, 0x01, 0x44, 0x38, 0x52, 0xff, 0x74, 0xe8, 0xeb, 0xcc, 0x48, 0x85, 0xc0, 0x0f, 0x85, 0xe7, 0x03, 0x00, 0x00,
			0x48, 0x8d, 0x41, 0x01, 0x0f, 0xb6, 0x10, 0x84, 0xd2, 0x74, 0x17, 0x48, 0x89, 0xc1, 0x80, 0xfa, 0x0a, 0x0f, 0x84,
			0x3a, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc1, 0x01, 0x0f, 0xb6, 0x11, 0x84, 0xd2, 0x75, 0xec, 0x48, 0x89, 0xc2, 0x4c,
			0x29, 0xca, 0x0f, 0x85, 0x3b, 0xff, 0xff, 0xff, 0x49, 0x89, 0xd0, 0x48, 0x89, 0xda, 0x4c, 0x29, 0xc2, 0x4b, 0x8d,
			0x34, 0x01, 0x41, 0xba, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x83, 0xf8, 0xfc,
			0x74, 0xed, 0x48, 0x85, 0xc0, 0x7e, 0x09, 0x49, 0x01, 0xc0, 0x42, 0xc6, 0x44, 0x04, 0x40, 0x00, 0x4d, 0x85, 0xc0,
			0x0f, 0x84, 0xc3, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x44, 0x24, 0x40, 0xeb, 0x98, 0x49, 0xc7, 0xc0, 0xff, 0xff, 0xff,
			0xff, 0xeb, 0xbc, 0x49, 0xc7, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xeb, 0xb3, 0x48, 0x8d, 0x54, 0x24, 0x40, 0x48, 0x39,
			0xd0, 0x74, 0x15, 0x48, 0x83, 0xc0, 0x01, 0x0f, 0xb6, 0x10, 0x84, 0xd2, 0x74, 0x50, 0x48, 0x89, 0xc1, 0xbb, 0x00,
			0x00, 0x00, 0x00, 0xeb, 0x22, 0x48, 0x8d, 0x44, 0x24, 0x40, 0xeb, 0xe8, 0x48, 0xc1, 0xe3, 0x04, 0x0f, 0xbe, 0xd2,
			0x83, 0xea, 0x30, 0x48, 0x63, 0xd2, 0x48, 0x01, 0xd3, 0x48, 0x83, 0xc1, 0x01, 0x0f, 0xb6, 0x11, 0x84, 0xd2, 0x74,
			0x29, 0x8d, 0x72, 0xd0, 0x40, 0x80, 0xfe, 0x09, 0x76, 0xdc, 0x8d, 0x72, 0x9f, 0x40, 0x80, 0xfe, 0x05, 0x77, 0x17,
			0x48, 0xc1, 0xe3, 0x04, 0x0f, 0xbe, 0xd2, 0x83, 0xea, 0x57, 0x48, 0x63, 0xd2, 0x48, 0x01, 0xd3, 0xeb, 0xd1, 0xbb,
			0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x80, 0x38, 0x20, 0x0f, 0x94, 0xc1, 0x0f, 0xb6, 0xc9, 0x01,
			0xca, 0x48, 0x83, 0xc0, 0x01, 0x83, 0xfa, 0x05, 0x75, 0xec, 0x80, 0x38, 0x20, 0x75, 0x09, 0x48, 0x83, 0xc0, 0x01,
			0x80, 0x38, 0x20, 0x74, 0xf7, 0x80, 0x38, 0x0a, 0x74, 0x09, 0x48, 0x83, 0xc0, 0x01, 0x80, 0x38, 0x0a, 0x75, 0xf7,
			0xc6, 0x00, 0x00, 0x41, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xeb, 0x0b, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00,
			0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x41, 0xba, 0x00, 0x00, 0x00, 0x00,
			0xb8, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xba, 0x01, 0x00, 0x00, 0x00, 0x45, 0x84, 0xc0, 0x0f, 0x84, 0x57, 0x02,
			0x00, 0x00, 0xc7, 0x44, 0x24, 0x30, 0x0d, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x55, 0x20, 0x48, 0x89, 0x54, 0x24, 0x38,
			0x48, 0x89, 0xd0, 0x48, 0x83, 0xc2, 0x68, 0xc6, 0x00, 0x00, 0x48, 0x83, 0xc0, 0x01, 0x48, 0x39, 0xd0, 0x75, 0xf4,
			0x0f, 0xb7, 0x73, 0x38, 0x66, 0x85, 0xf6, 0x74, 0x60, 0x0f, 0xb7, 0x7b, 0x36, 0x48, 0x89, 0xd8, 0x48, 0x03, 0x43,
			0x20, 0xba, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0x83, 0x38, 0x02, 0x74, 0x10, 0x83, 0xc2, 0x01, 0x48, 0x01,
			0xf8, 0x66, 0x39, 0xd6, 0x75, 0xed, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x51, 0x20, 0x48, 0x83, 0xfa, 0x0f,
			0x0f, 0x86, 0xe8, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x79, 0x10, 0x48, 0x8d, 0x44, 0x3b, 0x08, 0x48, 0x89, 0xd9, 0x48,
			0x89, 0xc7, 0x48, 0x83, 0xe2, 0xf0, 0x48, 0x01, 0xd7, 0x41, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x41, 0xbe, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xbc, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x13, 0xb9, 0x00, 0x00, 0x00, 0x00, 0xeb, 0xc1, 0x4c, 0x8b,
			0x20, 0x48, 0x83, 0xc0, 0x10, 0x48, 0x39, 0xc7, 0x74, 0x20, 0x48, 0x8b, 0x50, 0xf8, 0x48, 0x83, 0xfa, 0x06, 0x74,
			0xea, 0x48, 0x83, 0xfa, 0x0a, 0x74, 0x0b, 0x48, 0x83, 0xfa, 0x05, 0x75, 0xe1, 0x4c, 0x8b, 0x30, 0xeb, 0xdc, 0x4c,
			0x8b, 0x38, 0xeb, 0xd7, 0x4d, 0x85, 0xe4, 0x0f, 0x94, 0xc0, 0x4d, 0x85, 0xf6, 0x0f, 0x94, 0xc2, 0x08, 0xd0, 0x0f,
			0x85, 0x7e, 0x01, 0x00, 0x00, 0x4d, 0x85, 0xff, 0x0f, 0x84, 0x75, 0x01, 0x00, 0x00, 0x4d, 0x89, 0xe0, 0x49, 0x29,
			0xc8, 0x66, 0x85, 0xf6, 0x0f, 0x84, 0x80, 0x01, 0x00, 0x00, 0x44, 0x0f, 0xb7, 0x53, 0x36, 0x48, 0x89, 0xd8, 0x48,
			0x03, 0x43, 0x20, 0xbf, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x0b, 0x83, 0xc7, 0x01, 0x4c, 0x01, 0xd0, 0x66, 0x39, 0xf7,
			0x74, 0x5a, 0x83, 0x38, 0x01, 0x75, 0xf0, 0x4c, 0x8b, 0x48, 0x10, 0x4c, 0x89, 0xca, 0x48, 0x03, 0x50, 0x28, 0x4d,
			0x39, 0xc8, 0x72, 0xe0, 0x49, 0x39, 0xd0, 0x73, 0xdb, 0x4c, 0x29, 0xe1, 0x48, 0x01, 0xd1, 0x0f, 0x84, 0x43, 0x01,
			0x00, 0x00, 0x48, 0xba, 0xab, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x48, 0x89, 0xc8, 0x48, 0xf7, 0xe2, 0x48,
			0xc1, 0xea, 0x04, 0x48, 0x89, 0x14, 0x24, 0x48, 0x83, 0xf9, 0x17, 0x0f, 0x86, 0x28, 0x01, 0x00, 0x00, 0x41, 0xbd,
			0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x44, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x08, 0xeb, 0x18, 0xba, 0x02, 0x00,
			0x00, 0x00, 0xe9, 0xe9, 0x00, 0x00, 0x00, 0x49, 0x83, 0xc5, 0x01, 0x49, 0x83, 0xc4, 0x18, 0x4c, 0x39, 0x2c, 0x24,
			0x74, 0x5f, 0x41, 0x8b, 0x14, 0x24, 0x4c, 0x39, 0xfa, 0x73, 0x56, 0x66, 0x41, 0x83, 0x7c, 0x24, 0x06, 0x00, 0x74,
			0xe0, 0x41, 0x0f, 0xb6, 0x44, 0x24, 0x04, 0x89, 0xc1, 0x83, 0xe1, 0x0f, 0x88, 0x4c, 0x24, 0x20, 0x83, 0xe9, 0x01,
			0x80, 0xf9, 0x01, 0x77, 0xc9, 0xc0, 0xe8, 0x04, 0x88, 0x44, 0x24, 0x21, 0x83, 0xe8, 0x01, 0x3c, 0x01, 0x77, 0xbb,
			0x4c, 0x01, 0xf2, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0xd8, 0x49, 0x03, 0x44, 0x24, 0x08, 0x48, 0x89, 0x44,
			0x24, 0x18, 0x48, 0x8d, 0x7c, 0x24, 0x10, 0x48, 0x8b, 0x74, 0x24, 0x08, 0xe8, 0xde, 0xf8, 0xff, 0xff, 0x84, 0xc0,
			0x75, 0x93, 0x83, 0x7c, 0x24, 0x30, 0x00, 0x0f, 0x85, 0x9b, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x75, 0x00, 0x48, 0x8b,
			0x45, 0x20, 0x41, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x41, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xb9, 0x22, 0x00, 0x00, 0x00,
			0xba, 0x07, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0xff, 0x50, 0x10, 0x48, 0x89, 0x45, 0x08, 0x48, 0x83,
			0xf8, 0xff, 0x74, 0x72, 0xc7, 0x45, 0x14, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x45, 0x18, 0xff, 0xff, 0xff, 0xff, 0xba,
			0x00, 0x00, 0x00, 0x00, 0x83, 0x7d, 0x10, 0x00, 0x74, 0x28, 0x48, 0x8d, 0x4d, 0x14, 0x48, 0x8b, 0x45, 0x20, 0xbe,
			0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0xff, 0x50, 0x20, 0xba, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x0c,
			0xba, 0x02, 0x00, 0x00, 0x00, 0xeb, 0x05, 0xba, 0x02, 0x00, 0x00, 0x00, 0x48, 0x89, 0xd0, 0x48, 0x81, 0xc4, 0x48,
			0x08, 0x00, 0x00, 0x5b, 0x5d, 0x41, 0x5c, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0xc3, 0xba, 0x02, 0x00, 0x00, 0x00,
			0xeb, 0xe4, 0xba, 0x02, 0x00, 0x00, 0x00, 0xeb, 0xdd, 0xba, 0x02, 0x00, 0x00, 0x00, 0xeb, 0xd6, 0xba, 0x02, 0x00,
			0x00, 0x00, 0xeb, 0xcf, 0xba, 0x03, 0x00, 0x00, 0x00, 0xeb, 0xc8, 0x48, 0x8d, 0x54, 0x24, 0x40, 0x48, 0x89, 0xd1,
			0x48, 0x39, 0xd0, 0x74, 0x1c, 0x80, 0x38, 0x00, 0x0f, 0x84, 0x81, 0xfc, 0xff, 0xff, 0x48, 0x83, 0xe8, 0x01, 0x48,
			0x39, 0xc8, 0x75, 0xee, 0x48, 0x8d, 0x44, 0x24, 0x40, 0xe9, 0x7c, 0xfc, 0xff, 0xff, 0x48, 0x89, 0xd0, 0xe9, 0x74,
			0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x00,
			0x6d, 0x6d, 0x61, 0x70, 0x00, 0x6d, 0x75, 0x6e, 0x6d, 0x61, 0x70, 0x00, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x70,
			0x61, 0x69, 0x72, 0x00, 0x72, 0x65, 0x63, 0x76, 0x6d, 0x73, 0x67, 0x00, 0x73, 0x65, 0x6e, 0x64, 0x00, 0x70, 0x74,
			0x68, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x70, 0x74, 0x68, 0x72, 0x65, 0x61,
			0x64, 0x5f, 0x64, 0x65, 0x74, 0x61, 0x63, 0x68, 0x00, 0x64, 0x6c, 0x6f, 0x70, 0x65, 0x6e, 0x00, 0x64, 0x6c, 0x63,
			0x6c, 0x6f, 0x73, 0x65, 0x00, 0x64, 0x6c, 0x73, 0x79, 0x6d, 0x00, 0x6c, 0x69, 0x62, 0x63, 0x2e, 0x73, 0x6f, 0x00
		};

		private const uint BOOTSTRAPPER_ENTRYPOINT_OFFSET = 0x2f2;

		private const uint8[] LOADER_CODE = {
			0x48, 0x81, 0xec, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0xf0, 0x48, 0x8d, 0x54, 0x24, 0x7f, 0x48, 0x89, 0x54, 0x24,
			0x60, 0x48, 0xc7, 0x44, 0x24, 0x68, 0x01, 0x00, 0x00, 0x00, 0x66, 0x0f, 0xef, 0xc0, 0x0f, 0x29, 0x04, 0x24, 0x48,
			0xc7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x60, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48,
			0xc7, 0x44, 0x24, 0x18, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x40, 0x48, 0x89, 0x54, 0x24, 0x20, 0x48,
			0xc7, 0x44, 0x24, 0x28, 0x18, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe6, 0xba, 0x00, 0x00, 0x00, 0x00, 0xff, 0x50, 0x28,
			0x83, 0xc0, 0x01, 0x83, 0xf8, 0x01, 0x76, 0x1d, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0x7c, 0x24, 0x28, 0x0f,
			0x76, 0x05, 0x48, 0x8b, 0x44, 0x24, 0x20, 0x8b, 0x40, 0x10, 0x48, 0x81, 0xc4, 0x88, 0x00, 0x00, 0x00, 0xc3, 0xb8,
			0xff, 0xff, 0xff, 0xff, 0xeb, 0xf1, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x55, 0x53, 0x48, 0x83, 0xec,
			0x48, 0x48, 0x89, 0xfd, 0x48, 0x8b, 0x5f, 0x20, 0xc7, 0x44, 0x24, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x7f, 0x18,
			0x83, 0xff, 0xff, 0x74, 0x03, 0xff, 0x53, 0x38, 0x44, 0x8b, 0x65, 0x1c, 0x41, 0x83, 0xfc, 0xff, 0x75, 0x14, 0x48,
			0x8b, 0x7d, 0x00, 0xbe, 0x01, 0x01, 0x00, 0x00, 0xff, 0x53, 0x50, 0x49, 0x89, 0xc5, 0x45, 0x89, 0xe6, 0xeb, 0x50,
			0x48, 0x89, 0xde, 0x44, 0x89, 0xe7, 0xe8, 0x24, 0xff, 0xff, 0xff, 0x41, 0x89, 0xc7, 0x48, 0x89, 0xde, 0x44, 0x89,
			0xe7, 0xe8, 0x16, 0xff, 0xff, 0xff, 0x41, 0x89, 0xc6, 0x4c, 0x8d, 0x6c, 0x24, 0x10, 0x44, 0x89, 0xfa, 0x48, 0x8d,
			0x35, 0x04, 0x0f, 0x00, 0x00, 0x4c, 0x89, 0xef, 0xb8, 0x00, 0x00, 0x00, 0x00, 0xff, 0x53, 0x08, 0xbe, 0x01, 0x01,
			0x00, 0x00, 0x4c, 0x89, 0xef, 0xff, 0x53, 0x50, 0x49, 0x89, 0xc5, 0x41, 0x83, 0xff, 0xff, 0x74, 0x06, 0x44, 0x89,
			0xff, 0xff, 0x53, 0x38, 0x4d, 0x85, 0xed, 0x74, 0x3a, 0x48, 0x8b, 0x75, 0x08, 0x4c, 0x89, 0xef, 0xff, 0x53, 0x60,
			0x48, 0x85, 0xc0, 0x74, 0x24, 0x44, 0x89, 0x64, 0x24, 0x08, 0x44, 0x89, 0x74, 0x24, 0x0c, 0x48, 0x8d, 0x54, 0x24,
			0x08, 0x48, 0x8d, 0x74, 0x24, 0x3c, 0x48, 0x8b, 0x7d, 0x10, 0xff, 0xd0, 0x44, 0x8b, 0x64, 0x24, 0x08, 0x44, 0x8b,
			0x74, 0x24, 0x0c, 0x83, 0x7c, 0x24, 0x3c, 0x00, 0x74, 0x34, 0x83, 0x7c, 0x24, 0x3c, 0x02, 0x74, 0x07, 0x48, 0x8b,
			0x7d, 0x28, 0xff, 0x53, 0x48, 0x41, 0x83, 0xfe, 0xff, 0x74, 0x06, 0x44, 0x89, 0xf7, 0xff, 0x53, 0x38, 0x41, 0x83,
			0xfc, 0xff, 0x75, 0x1c, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xc4, 0x48, 0x5b, 0x5d, 0x41, 0x5c, 0x41, 0x5d,
			0x41, 0x5e, 0x41, 0x5f, 0xc3, 0x4c, 0x89, 0xef, 0xff, 0x53, 0x58, 0xeb, 0xc4, 0x8b, 0x44, 0x24, 0x3c, 0x89, 0x04,
			0x24, 0xbf, 0x00, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x41, 0xba, 0x00,
			0x00, 0x00, 0x00, 0xb8, 0xba, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x89, 0x44, 0x24, 0x04, 0x48, 0x89, 0xe6, 0xb9, 0x00,
			0x40, 0x00, 0x00, 0xba, 0x08, 0x00, 0x00, 0x00, 0x44, 0x89, 0xe7, 0xff, 0x53, 0x30, 0x44, 0x89, 0xe7, 0xff, 0x53,
			0x38, 0xeb, 0xa2, 0x48, 0x83, 0xec, 0x08, 0x48, 0x89, 0xf9, 0x48, 0x8d, 0x7f, 0x28, 0x48, 0x8b, 0x41, 0x20, 0x48,
			0x8d, 0x15, 0x97, 0xfe, 0xff, 0xff, 0xbe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x50, 0x40, 0xb8, 0x01, 0x00, 0x00, 0x00,
			0x48, 0x83, 0xc4, 0x08, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f, 0x70, 0x72, 0x6f, 0x63, 0x2f, 0x73, 0x65,
			0x6c, 0x66, 0x2f, 0x66, 0x64, 0x2f, 0x25, 0x64, 0x00
		};

		private const uint LOADER_ENTRYPOINT_OFFSET = 0x1de;
	}

	private class CleanupSession : SeizeSession {
		private CleanupSession (uint pid) {
			Object (pid: pid);
		}

		public static async CleanupSession open (uint pid, Cancellable? cancellable) throws Error, IOError {
			var session = new CleanupSession (pid);

			try {
				yield session.init_async (Priority.DEFAULT, cancellable);
			} catch (GLib.Error e) {
				if (e is Error)
					throw (Error) e;
				assert (e is IOError);
				throw (IOError) e;
			}

			return session;
		}

		public async void deallocate (RemoteAgent.MemoryLayout layout, Cancellable? cancellable) throws Error, IOError {
			var regs = saved_regs;
			regs.orig_rax = -1;

			regs.program_counter = layout.munmap_impl;

			regs.rdi = layout.loader_base;
			regs.rsi = layout.loader_size;

			regs.reserve_stack_space (RED_ZONE_SIZE);
			regs.reserve_stack_space ((size_t) (regs.stack_pointer % STACK_ALIGNMENT));

			regs.rsp -= 8;
			ptrace (POKEDATA, pid, (void *) regs.rsp, (void *) DUMMY_RETURN_ADDRESS);

			set_regs (&regs);

			ptrace (CONT, pid);
			yield wait_for_next_signal (cancellable);
			get_regs (&regs);
			if (regs.program_counter != DUMMY_RETURN_ADDRESS || regs.return_value != 0) {
				set_regs (&saved_regs);
				throw new Error.NOT_SUPPORTED ("Cleanup failed; please file a bug");
			}

			set_regs (&saved_regs);
		}
	}

	private class RemoteAgent : Object {
		public uint id {
			get;
			construct;
		}

		public uint pid {
			get;
			construct;
		}

		public MemoryLayout layout {
			get;
			construct;
		}

		public UnixConnection frida_ctrl {
			get;
			construct;
		}

		public UnixConnection agent_ctrl {
			get;
			construct;
		}

		public State state {
			get {
				return _state;
			}
		}

		public UnloadPolicy unload_policy {
			get {
				return _unload_policy;
			}
		}

		public enum State {
			STARTED,
			STOPPED
		}

		public class MemoryLayout {
			public uint64 loader_base {
				get;
				private set;
			}

			public size_t loader_size {
				get;
				private set;
			}

			public uint64 munmap_impl {
				get;
				private set;
			}

			public MemoryLayout (uint64 loader_base, size_t loader_size, uint64 munmap_impl) {
				this.loader_base = loader_base;
				this.loader_size = loader_size;
				this.munmap_impl = munmap_impl;
			}
		}

		private State _state = STARTED;
		private UnloadPolicy _unload_policy = IMMEDIATE;

		private Promise<bool> cancel_request = new Promise<bool> ();
		private Cancellable io_cancellable = new Cancellable ();

		private RemoteAgent (uint id, uint pid, MemoryLayout layout, UnixConnection frida_ctrl, UnixConnection agent_ctrl) {
			Object (
				id: id,
				pid: pid,
				layout: layout,
				frida_ctrl: frida_ctrl,
				agent_ctrl: agent_ctrl
			);
		}

		construct {
			monitor.begin ();
		}

		internal static RemoteAgent start (uint id, uint pid, MemoryLayout layout, UnixConnection frida_ctrl,
				string agent_path, Cancellable? cancellable) throws Error {
			UnixConnection agent_ctrl;
			try {
				var agent_codefd = new FileDescriptor (Posix.open (agent_path, Posix.O_RDONLY));
				if (agent_codefd.handle == -1)
					throw new Error.INVALID_ARGUMENT ("%s", strerror (errno));
				int agent_ctrlfds[2];
				if (Posix.socketpair (Posix.AF_UNIX, Posix.SOCK_STREAM, 0, agent_ctrlfds) != 0)
					throw new Error.NOT_SUPPORTED ("Unable to allocate socketpair");
				var agent_ctrlfd = new FileDescriptor (agent_ctrlfds[0]);
				var agent_ctrlfd_for_peer = new FileDescriptor (agent_ctrlfds[1]);

				frida_ctrl.send_fd (agent_codefd.handle, cancellable);
				frida_ctrl.send_fd (agent_ctrlfd_for_peer.handle, cancellable);

				Socket socket = new Socket.from_fd (agent_ctrlfd.handle);
				agent_ctrlfd.steal ();
				agent_ctrl = (UnixConnection) SocketConnection.factory_create_connection (socket);
			} catch (GLib.Error e) {
				throw new Error.TRANSPORT ("%s", e.message);
			}

			return new RemoteAgent (id, pid, layout, frida_ctrl, agent_ctrl);
		}

		private async void monitor () {
			try {
				var unload_policy = UnloadPolicy.IMMEDIATE;

				var bye = HelperByeMessage ();
				size_t bytes_read;
				yield frida_ctrl.get_input_stream ()
					.read_all_async ((uint8[]) &bye, Priority.DEFAULT, io_cancellable, out bytes_read);
				if (bytes_read != 0) {
					unload_policy = bye.unload_policy;

					var thread_path = "/proc/%u/task/%u".printf (pid, bye.thread_id);
					while (FileUtils.test (thread_path, EXISTS)) {
						Timeout.add (50, monitor.callback);
						yield;
					}
				}

				on_stop (unload_policy);
			} catch (GLib.Error e) {
				if (!(e is IOError.CANCELLED))
					on_stop (IMMEDIATE);
			}

			cancel_request.resolve (true);
		}

		public async void demonitor () {
			io_cancellable.cancel ();

			try {
				yield cancel_request.future.wait_async (null);
			} catch (GLib.Error e) {
				assert_not_reached ();
			}
		}

		private void on_stop (UnloadPolicy unload_policy) {
			_unload_policy = unload_policy;
			_state = STOPPED;
			notify_property ("state");
		}
	}

	protected struct HelperBootstrapContext {
		size_t loader_size;
		void * loader_base;
		bool enable_ctrlfds;
		int ctrlfds[2];
		HelperLibcApi * libc_api;
	}

	protected struct HelperLoaderContext {
		char * agent_path;
		char * agent_entrypoint;
		char * agent_parameters;

		int ctrlfds[2];
		HelperLibcApi * libc_api;

		void * worker;
	}

	protected struct HelperLibcApi {
		void * printf;
		void * sprintf;

		void * mmap;
		void * munmap;
		void * socketpair;
		void * recvmsg;
		void * send;
		void * close;

		void * pthread_create;
		void * pthread_detach;

		void * dlopen;
		void * dlclose;
		void * dlsym;
	}

	protected struct HelperByeMessage {
		UnloadPolicy unload_policy;
		uint thread_id;
	}

	protected class SeizeSession : Object, AsyncInitable {
		public uint pid {
			get;
			construct;
		}

		private AttachState attach_state = ALREADY_ATTACHED;
		protected int pidfd = -1;
		protected GPRegs saved_regs;

		private static bool seize_supported;
		protected static PidfdOpenFunc? pidfd_open;
		protected static PidfdGetfdFunc? pidfd_getfd;
		private static bool regset_supported = true;

		private static uint linux_major = 0;
		private static uint linux_minor = 0;

		[CCode (has_target = false)]
		protected delegate int PidfdOpenFunc (uint pid, uint flags);

		[CCode (has_target = false)]
		protected delegate int PidfdGetfdFunc (int pidfd, int targetfd, uint flags);

		protected const size_t RED_ZONE_SIZE = 128;
		protected const size_t STACK_ALIGNMENT = 16;
		protected const size_t DUMMY_RETURN_ADDRESS = 0x320;

		static construct {
			if (check_kernel_version (5, 3))
				pidfd_open = pidfd_open_impl;
			if (check_kernel_version (5, 6))
				pidfd_getfd = pidfd_getfd_impl;
			seize_supported = check_kernel_version (3, 4);
		}

		~SeizeSession () {
			if (pidfd != -1)
				Posix.close (pidfd);

			if (attach_state == ATTACHED)
				_ptrace (DETACH, pid);
		}

		private async bool init_async (int io_priority, Cancellable? cancellable) throws Error, IOError {
			long res;
			if (seize_supported)
				res = _ptrace (SEIZE, pid, null, (void *) PtraceOptions.TRACEEXEC);
			else
				res = _ptrace (ATTACH, pid);

			if (pidfd_open != null)
				pidfd = pidfd_open (pid, 0);
			else
				pidfd = -1;

			bool maybe_already_attached = res == -1 && errno == Posix.EPERM;
			if (maybe_already_attached) {
				get_regs (&saved_regs);

				attach_state = ALREADY_ATTACHED;
			} else {
				if (res == -1)
					throw_ptrace_error (pid, errno);

				attach_state = ATTACHED;

				if (seize_supported)
					ptrace (INTERRUPT, pid);

				yield wait_for_attach_signal (cancellable);

				get_regs (&saved_regs);
			}

			return true;
		}

		private async void wait_for_attach_signal (Cancellable? cancellable) throws Error, IOError {
			Posix.Signal stop_signal = yield wait_for_next_signal (cancellable);

			if (seize_supported) {
				bool probably_about_to_exec;
				switch (stop_signal) {
					case STOP:
					case TTIN:
					case TTOU:
						probably_about_to_exec = true;
						break;
					default:
						probably_about_to_exec = false;
						break;
				}

				if (probably_about_to_exec) {
					ptrace (CONT, pid);
					yield wait_for_signal (TRAP, cancellable);
				} else {
					if (stop_signal != TRAP)
						throw new Error.NOT_SUPPORTED ("Expected SIGTRAP, got %d", stop_signal);
				}
			} else {
				switch (stop_signal) {
					case TRAP:
						ptrace (CONT, pid);
						yield wait_for_signal (STOP, cancellable);
						break;
					case STOP:
						break;
					default:
						throw new Error.NOT_SUPPORTED ("Expected SIGSTOP, got %d", stop_signal);
				}
			}
		}

		protected async void wait_for_signal (Posix.Signal expected_signal, Cancellable? cancellable) throws Error, IOError {
			Posix.Signal next_signal = yield wait_for_next_signal (cancellable);
			if (next_signal != expected_signal)
				throw new Error.NOT_SUPPORTED ("Expected signal %d, got %d", expected_signal, next_signal);
		}

		protected async Posix.Signal wait_for_next_signal (Cancellable? cancellable) throws Error, IOError {
			int status = 0;
			int res = 0;
			do {
				res = Posix.waitpid ((Posix.pid_t) pid, out status, Posix.WNOHANG);
				int errsv = errno;
				if (res == -1)
					throw new Error.NOT_SUPPORTED ("%s", strerror (errsv));
				if (res != 0)
					break;

				var main_context = MainContext.get_thread_default ();

				var delay_source = new TimeoutSource (20);
				delay_source.set_callback (wait_for_next_signal.callback);
				delay_source.attach (main_context);

				var cancel_source = new CancellableSource (cancellable);
				cancel_source.set_callback (wait_for_next_signal.callback);
				cancel_source.attach (main_context);

				yield;

				cancel_source.destroy ();
				delay_source.destroy ();
			} while (!cancellable.set_error_if_cancelled ());

			if (PosixStatus.is_exit (status)) {
				throw new Error.NOT_SUPPORTED ("Target exited with status %u",
					PosixStatus.parse_exit_status (status));
			}

			if (PosixStatus.is_signaled (status)) {
				throw new Error.NOT_SUPPORTED ("Target terminated with signal %u",
					PosixStatus.parse_termination_signal (status));
			}

			if (!PosixStatus.is_stopped (status))
				throw new Error.NOT_SUPPORTED ("Unexpected status: 0x%08x", status);
			return PosixStatus.parse_stop_signal (status);
		}

		protected void get_regs (GPRegs * regs) throws Error {
			if (regset_supported) {
				var io = Posix.iovector ();
				io.iov_base = regs;
				io.iov_len = sizeof (GPRegs);
				long res = _ptrace (GETREGSET, pid, (void *) NT_PRSTATUS, &io);
				if (res == 0)
					return;
				if (errno == Posix.EPERM || errno == Posix.ESRCH)
					throw_ptrace_error (pid, errno);
				regset_supported = false;
			}

			ptrace (GETREGS, pid, null, regs);
		}

		protected void set_regs (GPRegs * regs) throws Error {
			if (regset_supported) {
				var io = Posix.iovector ();
				io.iov_base = regs;
				io.iov_len = sizeof (GPRegs);
				long res = _ptrace (SETREGSET, pid, (void *) NT_PRSTATUS, &io);
				if (res == 0)
					return;
				if (errno == Posix.EPERM || errno == Posix.ESRCH)
					throw_ptrace_error (pid, errno);
				regset_supported = false;
			}

			ptrace (SETREGS, pid, null, regs);
		}

		protected uint8[] read_memory (uint64 address, size_t size) throws Error {
			var result = new uint8[size];

			size_t offset = 0;
			uint bytes_per_word = (uint) sizeof (size_t);
			while (offset != size) {
				size_t word = (size_t) ptrace (PEEKDATA, pid, (void *) (address + offset));
				size_t chunk_size = size_t.min (size - offset, bytes_per_word);
				Memory.copy ((uint8 *) result + offset, &word, chunk_size);

				offset += chunk_size;
			}

			return result;
		}

		protected void write_memory (uint64 address, uint8[] data) throws Error {
			size_t offset = 0;
			size_t size = data.length;
			uint bytes_per_word = (uint) sizeof (size_t);
			while (offset != size) {
				size_t word = 0;
				size_t chunk_size = size_t.min (size - offset, bytes_per_word);
				if (chunk_size < bytes_per_word)
					word = (size_t) ptrace (PEEKDATA, pid, (void *) (address + offset));
				Memory.copy (&word, (uint8 *) data + offset, chunk_size);

				ptrace (POKEDATA, pid, (void *) (address + offset), (void *) word);

				offset += chunk_size;
			}
		}

		private static bool check_kernel_version (uint major, uint minor) {
			if (linux_major == 0) {
				var name = Posix.utsname ();
				name.release.scanf ("%u.%u", out linux_major, out linux_minor);
			}

			return (linux_major == major && linux_minor >= minor) || linux_major > major;
		}

		private static int pidfd_open_impl (uint pid, uint flags) {
			return Linux.syscall (SysCall.pidfd_open, pid, flags);
		}

		private static int pidfd_getfd_impl (int pidfd, int targetfd, uint flags) {
			return Linux.syscall (SysCall.pidfd_getfd, pidfd, targetfd, flags);
		}
	}

	protected enum AttachState {
		ATTACHED,
		ALREADY_ATTACHED,
	}

	private class RemoteThreadSession : Object {
		public signal void ended (UnloadPolicy unload_policy);

		public uint id {
			get;
			construct;
		}

		public uint pid {
			get;
			construct;
		}

		public InputStream input {
			get;
			construct;
		}

		private Promise<bool> cancel_request = new Promise<bool> ();
		private Cancellable cancellable = new Cancellable ();

		public RemoteThreadSession (uint id, uint pid, InputStream input) {
			Object (id: id, pid: pid, input: input);
		}

		public async void establish () throws Error {
			var timeout = Timeout.add_seconds (2, () => {
				cancellable.cancel ();
				return false;
			});

			ssize_t size = 0;
			var byte_buf = new uint8[1];
			try {
				size = yield input.read_async (byte_buf, Priority.DEFAULT, cancellable);
			} catch (IOError e) {
				if (e is IOError.CANCELLED) {
					throw new Error.PROCESS_NOT_RESPONDING (
						"Unexpectedly timed out while waiting for FIFO to establish");
				} else {
					Source.remove (timeout);

					throw new Error.PROCESS_NOT_RESPONDING ("%s", e.message);
				}
			}

			Source.remove (timeout);

			if (size == 1 && byte_buf[0] != ProgressMessageType.HELLO)
				throw new Error.PROTOCOL ("Unexpected message received");

			if (size == 0) {
				cancel_request.resolve (true);

				Idle.add (() => {
					ended (IMMEDIATE);
					return false;
				});
			} else {
				monitor.begin ();
			}
		}

		public async void cancel () {
			cancellable.cancel ();

			try {
				yield cancel_request.future.wait_async (null);
			} catch (GLib.Error e) {
				assert_not_reached ();
			}
		}

		private async void monitor () {
			try {
				var unload_policy = UnloadPolicy.IMMEDIATE;

				var byte_buf = new uint8[1];
				var size = yield input.read_async (byte_buf, Priority.DEFAULT, cancellable);
				if (size == 1) {
					unload_policy = (UnloadPolicy) byte_buf[0];

					var tid_buf = new uint8[4];
					yield input.read_all_async (tid_buf, Priority.DEFAULT, cancellable, null);
					var tid = *((uint *) tid_buf);

					yield input.read_async (byte_buf, Priority.DEFAULT, cancellable);

					var thread_path = "/proc/%u/task/%u".printf (pid, tid);
					while (FileUtils.test (thread_path, EXISTS)) {
						Timeout.add (50, monitor.callback);
						yield;
					}
				}

				ended (unload_policy);
			} catch (GLib.Error e) {
				if (!(e is IOError.CANCELLED))
					ended (IMMEDIATE);
			}

			cancel_request.resolve (true);
		}
	}

	protected enum ProgressMessageType {
		HELLO = 0xff
	}

	protected class StdioPipes : Object {
		public int input {
			get;
			construct;
		}

		public int output {
			get;
			construct;
		}

		public int error {
			get;
			construct;
		}

		public StdioPipes (int input, int output, int error) {
			Object (input: input, output: output, error: error);
		}

		construct {
			try {
				Unix.set_fd_nonblocking (input, true);
				Unix.set_fd_nonblocking (output, true);
				Unix.set_fd_nonblocking (error, true);
			} catch (GLib.Error e) {
				assert_not_reached ();
			}
		}

		~StdioPipes () {
			Posix.close (input);
			Posix.close (output);
			Posix.close (error);
		}
	}

	private enum PtraceRequest {
		PEEKDATA	= 0x0002,
		POKEDATA	= 0x0005,
		CONT		= 0x0007,
		ATTACH		= 0x0010,
		GETREGS		= 0x000c,
		SETREGS		= 0x000d,
		DETACH		= 0x0011,
		GETREGSET	= 0x4204,
		SETREGSET	= 0x4205,
		SEIZE		= 0x4206,
		INTERRUPT	= 0x4207,
	}

	[Flags]
	private enum PtraceOptions {
		TRACEEXEC	= (1 << 4),
	}

	private const uint NT_PRSTATUS = 1;

	protected struct GPRegs {
#if X86
		uint32 ebx;
		uint32 ecx;
		uint32 edx;
		uint32 esi;
		uint32 edi;
		uint32 ebp;
		uint32 eax;
		uint32 xds;
		uint32 xes;
		uint32 xfs;
		uint32 xgs;
		int32 orig_eax;
		uint32 eip;
		uint32 xcs;
		uint32 eflags;
		uint32 esp;
		uint32 xss;

		public uint64 get_pc () {
			return eip;
		}
#elif X86_64
		uint64 r15;
		uint64 r14;
		uint64 r13;
		uint64 r12;
		uint64 rbp;
		uint64 rbx;
		uint64 r11;
		uint64 r10;
		uint64 r9;
		uint64 r8;
		uint64 rax;
		uint64 rcx;
		uint64 rdx;
		uint64 rsi;
		uint64 rdi;
		int64 orig_rax;
		uint64 rip;
		uint64 cs;
		uint64 eflags;
		uint64 rsp;
		uint64 ss;
		uint64 fs_base;
		uint64 gs_base;
		uint64 ds;
		uint64 es;
		uint64 fs;
		uint64 gs;

		public uint64 program_counter {
			get { return rip; }
			set { rip = value; }
		}

		public uint64 stack_pointer {
			get { return rsp; }
			set { rsp = value; }
		}

		public uint64 return_value {
			get { return rax; }
		}

		public uint64 reserve_stack_space (size_t amount) {
			rsp -= amount;
			return rsp;
		}

		public uint64 release_stack_space (size_t amount) {
			rsp += amount;
			return rsp;
		}
#elif ARM
		uint32 r[11];
		uint32 fp;
		uint32 ip;
		uint32 sp;
		uint32 lr;
		uint32 pc;
		uint32 cpsr;
		int32 orig_r0;

		public uint64 get_pc () {
			return pc;
		}
#elif ARM64
		uint64 regs[31];
		uint64 sp;
		uint64 pc;
		uint64 pstate;

		public uint64 get_pc () {
			return pc;
		}
#elif MIPS
		uint64 zero;
		uint64 at;
		uint64 v0;
		uint64 v1;
		uint64 a0;
		uint64 a1;
		uint64 a2;
		uint64 a3;
		uint64 t0;
		uint64 t1;
		uint64 t2;
		uint64 t3;
		uint64 t4;
		uint64 t5;
		uint64 t6;
		uint64 t7;
		uint64 s0;
		uint64 s1;
		uint64 s2;
		uint64 s3;
		uint64 s4;
		uint64 s5;
		uint64 s6;
		uint64 s7;
		uint64 t8;
		uint64 t9;
		uint64 k0;
		uint64 k1;
		uint64 gp;
		uint64 sp;
		uint64 fp;
		uint64 ra;

		uint64 lo;
		uint64 hi;

		uint64 pc;
		uint64 badvaddr;
		uint64 status;
		uint64 cause;

		uint64 __padding[8];

		public uint64 get_pc () {
			return pc;
		}
#endif
	}

	private long ptrace (PtraceRequest request, uint pid, void * addr = null, void * data = null) throws Error {
		long res = _ptrace (request, pid, addr, data);
		if (res == -1)
			throw_ptrace_error (pid, errno);
		return res;
	}

	[CCode (cname = "ptrace", cheader_filename = "sys/ptrace.h")]
	private extern long _ptrace (PtraceRequest request, uint pid, void * addr = null, void * data = null);

	[NoReturn]
	private void throw_ptrace_error (uint pid, int err) throws Error {
		switch (err) {
			case Posix.ESRCH:
				throw new Error.PROCESS_NOT_FOUND ("%s", strerror (errno));
			case Posix.EPERM:
				throw new Error.PERMISSION_DENIED (
					"Unable to access process with pid %u due to system restrictions;" +
					" try `sudo sysctl kernel.yama.ptrace_scope=0`, or run Frida as root",
					pid, strerror (errno));
			default:
				throw new Error.NOT_SUPPORTED ("%s", strerror (errno));
		}
	}

	namespace PosixStatus {
		[CCode (cname = "WIFEXITED", cheader_filename = "sys/wait.h")]
		private extern bool is_exit (int status);

		[CCode (cname = "WIFSIGNALED", cheader_filename = "sys/wait.h")]
		private extern bool is_signaled (int status);

		[CCode (cname = "WIFSTOPPED", cheader_filename = "sys/wait.h")]
		private extern bool is_stopped (int status);

		[CCode (cname = "WEXITSTATUS", cheader_filename = "sys/wait.h")]
		private extern uint parse_exit_status (int status);

		[CCode (cname = "WTERMSIG", cheader_filename = "sys/wait.h")]
		private extern Posix.Signal parse_termination_signal (int status);

		[CCode (cname = "WSTOPSIG", cheader_filename = "sys/wait.h")]
		private extern Posix.Signal parse_stop_signal (int status);
	}

	[CCode (cprefix = "SYS_", has_type_id = false, cname = "int")]
	private enum SysCall {
		pidfd_open,
		pidfd_getfd,
	}

	private class FileDescriptor {
		public int handle;

		public FileDescriptor (int handle) {
			this.handle = handle;
		}

		~FileDescriptor () {
			if (handle != -1)
				Posix.close (handle);
		}

		public int steal () {
			int result = handle;
			handle = -1;
			return result;
		}
	}
}
